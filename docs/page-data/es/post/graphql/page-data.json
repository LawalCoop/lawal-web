{
    "componentChunkName": "component---src-blog-templates-blog-post-js",
    "path": "/es/post/graphql",
    "result": {"data":{"allMarkdownRemark":{"edges":[{"node":{"id":"4b8f9f6d-3cd5-5b4c-bd51-091315d1cfbe","html":"<h1>Conociendo GraphQL</h1>\n<p>GraphQL define dos elementos:</p>\n<ul>\n<li>Un lenguaje de consulta</li>\n</ul>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 676px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/351436b1988b4a2416907b219e168787/243f7/Request_graphQL.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 45.33333333333333%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAJABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAQACBf/EABUBAQEAAAAAAAAAAAAAAAAAAAAB/9oADAMBAAIQAxAAAAHuaEYk/8QAFhABAQEAAAAAAAAAAAAAAAAAEAEx/9oACAEBAAEFAmYf/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAFBABAAAAAAAAAAAAAAAAAAAAIP/aAAgBAQAGPwJf/8QAGBAAAgMAAAAAAAAAAAAAAAAAAAEgIXH/2gAIAQEAAT8hxlxP/9oADAMBAAIAAwAAABDI/wD/xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/ED//xAAVEQEBAAAAAAAAAAAAAAAAAAAAEf/aAAgBAgEBPxCI/8QAGxABAAICAwAAAAAAAAAAAAAAAQAxEBFBYXH/2gAIAQEAAT8QLRN3A5M13KPXBP/Z'); background-size: cover; display: block;\"></span>\n  <picture>\n          <source srcset=\"/static/351436b1988b4a2416907b219e168787/e922d/Request_graphQL.webp 375w,\n/static/351436b1988b4a2416907b219e168787/c7990/Request_graphQL.webp 676w\" sizes=\"(max-width: 676px) 100vw, 676px\" type=\"image/webp\">\n          <source srcset=\"/static/351436b1988b4a2416907b219e168787/8a6f5/Request_graphQL.jpg 375w,\n/static/351436b1988b4a2416907b219e168787/243f7/Request_graphQL.jpg 676w\" sizes=\"(max-width: 676px) 100vw, 676px\" type=\"image/jpeg\">\n          <img class=\"gatsby-resp-image-image\" src=\"/static/351436b1988b4a2416907b219e168787/243f7/Request_graphQL.jpg\" alt=\"Request graphQL\" title=\"Request graphQL\" loading=\"lazy\" decoding=\"async\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\">\n        </picture>\n  </a>\n    </span>\n* Un entorno de ejecución para responder a estas consultas a través de la especificación de un esquema tipado en el que se enlistan los datos que el servicio web puede entregar y las operaciones para dar respuesta a las solicitudes de los clientes. \n<p>GraphQL permite que los desarrolladores creen consultas para extraer datos de varias fuentes en una sola llamada a la API.</p>\n<h1>GraphQL vs REST</h1>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 661px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/ca6bb0daf8123e64fa9d293c661b7eb9/b6814/GraphQL_Rest.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 60%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAMABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAECBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAew1Cg//xAAXEAEAAwAAAAAAAAAAAAAAAAABACAx/9oACAEBAAEFAljlP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABQQAQAAAAAAAAAAAAAAAAAAACD/2gAIAQEABj8CX//EABkQAAIDAQAAAAAAAAAAAAAAAAABEBExYf/aAAgBAQABPyFF6NpRRXRH/9oADAMBAAIAAwAAABDbz//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EABoQAQADAQEBAAAAAAAAAAAAAAEAESExUWH/2gAIAQEAAT8QASpTpM9qPEhwxPjGzdsbBrkFHs//2Q=='); background-size: cover; display: block;\"></span>\n  <picture>\n          <source srcset=\"/static/ca6bb0daf8123e64fa9d293c661b7eb9/e922d/GraphQL_Rest.webp 375w,\n/static/ca6bb0daf8123e64fa9d293c661b7eb9/07833/GraphQL_Rest.webp 661w\" sizes=\"(max-width: 661px) 100vw, 661px\" type=\"image/webp\">\n          <source srcset=\"/static/ca6bb0daf8123e64fa9d293c661b7eb9/8a6f5/GraphQL_Rest.jpg 375w,\n/static/ca6bb0daf8123e64fa9d293c661b7eb9/b6814/GraphQL_Rest.jpg 661w\" sizes=\"(max-width: 661px) 100vw, 661px\" type=\"image/jpeg\">\n          <img class=\"gatsby-resp-image-image\" src=\"/static/ca6bb0daf8123e64fa9d293c661b7eb9/b6814/GraphQL_Rest.jpg\" alt=\"GraphQL Rest\" title=\"GraphQL Rest\" loading=\"lazy\" decoding=\"async\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\">\n        </picture>\n  </a>\n    </span>\nLa principal diferencia entre las dos arquitecturas es que GraphQL es independiente de la base de datos y funciona mediante la creación de un único endpoint responsable de aceptar las consultas, en lugar de basarse en el enfoque de la API REST de tener endpoints separados para cada servicio. \n<p>GraphQL es un lenguaje orientado al cliente. Tiene una arquitectura en la que la aplicación front-end decide qué datos obtener y cuánto debe devolver el servidor. Mientras tanto, al usar REST, todo está diseñado en el servidor, por lo que el servidor impulsa la arquitectura.</p>\n<p>No hay problemas de over-fetching y under-fetching. Una ventaja de GraphQl sobre REST es que las respuestas REST contienen demasiados datos o a veces no los suficientes, lo que crea la necesidad de otra solicitud. GraphQL resuelve este problema obteniendo sólo los datos exactos y específicos en una única solicitud.</p>\n<p>Pero esto no es una rivalidad, pueden ser complementarios! la manera en la que el entorno de ejecución que resuelve las queries puede acceder a cualquier tipo de fuente de datos, como lo puede ser un ORM de una base de datos o llamadas a API de 3ros.</p>\n<h1>¿Por qué y cuándo usar GraphQL?</h1>\n<p>Una buena situación para usar GraphQL es cuando:</p>\n<ul>\n<li>Su aplicación necesita manejar un gran número de consultas y mutaciones diferentes, y una API REST tradicional sería difícil de administrar.</li>\n<li>Su aplicación necesita manejar una variedad de tipos de datos diferentes, y un esquema GraphQL permite una mejor organización y documentación de los datos.</li>\n<li>Su aplicación del lado del cliente necesita tener un control preciso sobre los datos que recibe del servidor, y GraphQL permite mayor flexibilidad en la recuperación y consulta de datos.</li>\n<li>Su aplicación va a ser utilizada por otros desarrolladores o sistemas de terceros y desea proporcionarles una API clara y bien documentada.</li>\n<li>Su aplicación necesita manejar actualizaciones en tiempo real y suscripciones, GraphQL proporciona soporte nativo para las suscripciones que puede ayudarte a implementar esta característica.</li>\n</ul>\n<p>Razones para usar GraphQL:</p>\n<ul>\n<li>Flexibilidad: permite al cliente solicitar solo los datos específicos que necesita, evitando la sobrecarga o subestimación de datos.</li>\n<li>Tipado fuerte: GraphQL proporciona un esquema claro y fácil de entender, lo que permite una mejor documentación y un manejo de errores más robusto.</li>\n<li>Eficiente: ya que el cliente puede especificar exactamente qué datos necesita, a menudo se pueden combinar varias solicitudes en una sola solicitud.</li>\n</ul>\n<p>Razones para no usar GraphQL:</p>\n<ul>\n<li>Curva de aprendizaje: GraphQL tiene una curva de aprendizaje más pronunciada que REST, y los desarrolladores pueden necesitar pasar más tiempo para familiarizarse con él.</li>\n<li>Caching: GraphQL no tiene mecanismos de almacenamiento en caché incorporados, lo que puede hacer más difícil almacenar en caché las respuestas del servidor.</li>\n<li>Sobrecarga: si el cliente especifica demasiados datos en su solicitud, puede acabar sobrecargando, lo que puede generar problemas de rendimiento.</li>\n</ul>\n<h1>Pros y contras</h1>\n<p>Pros</p>\n<ul>\n<li>GraphQL es mucho más rápido que otras API de comunicación porque le facilita reducir las requests eligiendo sólo los campos específicos que desea consultar.</li>\n<li>Sistemas complejos y microservicios. Podemos integrar múltiples sistemas detrás de la API de GraphQL. Los unifica y oculta su complejidad. El servidor GraphQL también se utiliza para obtener datos de los sistemas existentes y empaquetarlos en el formato de respuesta GraphQL. Esto es muy beneficioso para las infraestructuras heredadas o las API de terceros que tienen un tamaño enorme y son difíciles de mantener y manejar. Cuando tenemos que migrar de una aplicación backend monolítica a una arquitectura de microservicios, la API GraphQL puede ayudarnos a gestionar la comunicación entre múltiples microservicios fusionándose en un esquema GraphQL.</li>\n<li>Define una forma de datos: Cuando hacemos request GraphQL al servidor, éste devuelve la respuesta en una forma simple, segura y predecible. Así, te facilita escribir una consulta específica de acuerdo a tu requerimiento.</li>\n<li>Código compartido: Podemos compartir los campos GraphQL utilizados en múltiples consultas a un nivel de componente superior para su reutilización. Esta característica se conoce como fragmentos y permite obtener datos diferentes manteniendo el mismo campo de esquema.</li>\n<li>GraphQL es un lenguaje fuertemente tipado donde cada nivel de una consulta GraphQL corresponde a un tipo particular, y cada tipo describe un conjunto de campos disponibles. Por lo tanto, es similar a SQL y proporciona mensajes de error descriptivos antes de ejecutar una consulta.</li>\n<li>Introspection: Podemos consultar un servidor GraphQL por sus tipos de soporte. Crea una potente plataforma para herramientas y software cliente como el framework, Relay, o IDEs como GraphiQL. GraphiQL facilita a los desarrolladores aprender y explorar una API rápidamente.</li>\n<li>No se requiere la última versión. En GraphQL, el conjunto de resultados o datos devueltos es muy específico según la consulta del cliente, por lo que; es muy simple y fácil para el servidor generalizarlo. Cuando añadimos nuevas características de producto, campos adicionales al servidor, no afectan a los clientes existentes. Usted puede utilizar el servidor anterior sin ninguna preocupación porque los campos del servidor pueden ser obsoletos pero siguen funcionando. Este proceso compatible no requiere la necesidad de un número de versión creciente. Puedes ver que Facebook está utilizando la misma versión de GraphQL API en sus aplicaciones.</li>\n</ul>\n<p>Contras</p>\n<ul>\n<li>Las consultas siempre devuelven un código de estado HTTP de 200, independientemente de si la consulta se ha realizado correctamente o no. Si la consulta no tiene éxito, su respuesta JSON tendrá una clave de “errors:” de nivel superior con mensajes de error asociados y stacktrace. Esto puede hacer que sea mucho más difícil hacer la gestión de errores.</li>\n<li>Según su implementación, GraphQL podría requerir estrategias de gestión de API diferentes a las API de REST, sobre todo si se tienen en cuenta los precios y los límites de frecuencia.</li>\n<li>La flexibilidad y riqueza del lenguaje de consulta también añade complejidad que puede no valer la pena para APIs mas sencillas.</li>\n</ul>\n<h1>Ejemplo básico:</h1>\n<p>Para este ejemplo vamos a estar utilizando la librería de <a href=\"https://www.apollographql.com/docs/\">apollo</a>  que nos brinda en este caso un cliente para react y un servidor para nodeJS\r\nEl schema definido será uno muy simple de un blog donde los usuarios pueden tener posts asociados</p>\n<deckgo-highlight-code language=\"typescript\" terminal=\"ubuntu\"  >\n          <code slot=\"code\">type User {\r\n  id: ID!\r\n  name: String!\r\n  lastName: String!\r\n  emails: [String!]\r\n  age: Int!\r\n  posts: [Post]\r\n}\r\n\r\ntype Post {\r\n  id: ID!\r\n  title: String!\r\n  content: String!\r\n}\r\n\r\ntype Query {\r\n  user(id: ID!): User\r\n  post(id: ID!): Post\r\n  allUsers: [User]\r\n  allPosts: [Post]\r\n}</code>\n        </deckgo-highlight-code>\n<p>Server:</p>\n<deckgo-highlight-code language=\"javascript\" terminal=\"ubuntu\"  >\n          <code slot=\"code\">const { ApolloServer, gql } = require(&#39;apollo-server&#39;);\r\n\r\n\r\n// Definir tipos de datos y resolvers\r\nconst typeDefs = gql`\r\n type User {\r\n   id: ID!\r\n   name: String!\r\n   lastName: String!\r\n   emails: [String!]\r\n   age: Int!\r\n   posts: [Post]\r\n }\r\n type Post {\r\n   id: ID!\r\n   title: String!\r\n   content: String!\r\n }\r\n type Query {\r\n   user(id: ID!): User\r\n   post(id: ID!): Post\r\n   allUsers: [User]\r\n   allPosts: [Post]\r\n }\r\n`;\r\n\r\n\r\nconst users = [\r\n { name: &#39;John&#39;, lastName: &#39;Doe&#39;, emails: [&#39;johndoe@example.com&#39;], age: 30 },\r\n { name: &#39;Jane&#39;, lastName: &#39;Doe&#39;, emails: [&#39;janedoe@example.com&#39;], age: 25 },\r\n];\r\n\r\n\r\nconst posts = [\r\n { id: &#39;1&#39;, title: &#39;My first post&#39;, content: &#39;This is my first post&#39; },\r\n { id: &#39;2&#39;, title: &#39;My second post&#39;, content: &#39;This is my second post&#39; },\r\n];\r\n\r\n\r\nconst resolvers = {\r\n Query: {\r\n   // En los resolvers podriamos hacer una llamada a una api de 3ros\r\n   user: (_, { id }) =&gt; users.find((user) =&gt; user.id === id),\r\n   post: (_, { id }) =&gt; posts.find((post) =&gt; post.id === id),\r\n   allUsers: () =&gt; users,\r\n   allPosts: () =&gt; posts,\r\n },\r\n};\r\n\r\n\r\n// Creamos la instancia del servidor\r\nconst server = new ApolloServer({ typeDefs, resolvers });\r\n\r\n// Inicializamos el servidor\r\nserver.listen().then(({ url }) =&gt; {\r\n console.log(`Server ready at ${url}`);\r\n});\r\n</code>\n        </deckgo-highlight-code>\n<p>Cliente de react</p>\n<deckgo-highlight-code language=\"javascript\" terminal=\"ubuntu\"  >\n          <code slot=\"code\">import React from &#39;react&#39;;\r\nimport { ApolloClient, ApolloProvider, gql, useQuery } from &#39;@apollo/client&#39;;\r\n\r\n\r\nconst client = new ApolloClient({\r\n uri: &#39;http://localhost:4000/graphql&#39;,\r\n});\r\n\r\n\r\nfunction User({ id }) {\r\n const { loading, error, data } = useQuery(gql`\r\n   query User($id: ID!) {\r\n     user(id: $id) {\r\n       name\r\n       lastName\r\n       emails\r\n       age\r\n     }\r\n   }\r\n `, { variables: { id } });\r\n\r\n\r\n if (loading) return &lt;p&gt;Loading...&lt;/p&gt;;\r\n if (error) return &lt;p&gt;Error :(&lt;/p&gt;;\r\n\r\n\r\n return (\r\n   &lt;div&gt;\r\n     &lt;h2&gt;{data.user.name} {data.user.lastName}&lt;/h2&gt;\r\n     &lt;p&gt;Age: {data.user.age}&lt;/p&gt;\r\n     &lt;p&gt;Emails: {data.user.emails.join(&#39;, &#39;)}&lt;/p&gt;\r\n   &lt;/div&gt;\r\n );\r\n}\r\n\r\n\r\nfunction App() {\r\n return (\r\n   &lt;ApolloProvider client={client}&gt;\r\n     &lt;User id=&quot;1&quot; /&gt;\r\n   &lt;/ApolloProvider&gt;\r\n );\r\n}\r\n\r\n\r\nexport default App;</code>\n        </deckgo-highlight-code>\n<p>En este ejemplo, el componente User utiliza el hook useQuery de react-apollo para consultar al servidor un usuario específico por ID. El componente ApolloProvider se utiliza para proporcionar la instancia de cliente a toda la aplicación React. Cuando el componente es renderizado</p>\n<h1>Algunos extras:</h1>\n<p>GraphQL fue desarrollado internamente por Facebook en 2012 antes de ser liberado públicamente en 2015. ​ El 7 de noviembre de 2018, el proyecto GraphQL fue transferido de Facebook a la recién establecida Fundación GraphQL, alojada por la Fundación Linux.</p>\n<p>Los servidores de GraphQL están disponibles para múltiples lenguajes, incluyendo Haskell, Javascript, Perl, Python, Ruby, Java, C++,11​ C#, Scala, Go, Rust, Elixir, Erlang, PHP, R, y Clojure.</p>\n<p>Documentación oficial de GraphQL: <a href=\"https://graphql.org/learn/\">https://graphql.org/learn/</a>\r\nDocumentación oficial de Apollo: <a href=\"https://www.apollographql.com/docs/\">https://www.apollographql.com/docs/</a></p>","frontmatter":{"lang":"en","type":"post","title":"Conociendo Graphql","author":"Jeronimo Clinaz","slug":"/graphql","date":"2023-02-08","tags":["GraphQL","Apollo","Rest"],"image":{"childImageSharp":{"fluid":{"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAMABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAABQACA//EABUBAQEAAAAAAAAAAAAAAAAAAAMC/9oADAMBAAIQAxAAAAFznss0VhqH/8QAGhAAAgMBAQAAAAAAAAAAAAAAAQIAAxIRE//aAAgBAQABBQKWMQuhLDlPR4T0/wD/xAAaEQACAgMAAAAAAAAAAAAAAAAAAQIDFCFR/9oACAEDAQE/AY1Oa0Y66f/EABgRAAIDAAAAAAAAAAAAAAAAAAACERMh/9oACAECAQE/AXaMLT//xAAZEAEBAAMBAAAAAAAAAAAAAAABABEhIjL/2gAIAQEABj8CubaSl6bLf//EABkQAQEBAQEBAAAAAAAAAAAAAAERADEQUf/aAAgBAQABPyHjHHU1unxPy5OuDwEsV3//2gAMAwEAAgADAAAAEAMP/8QAFxEAAwEAAAAAAAAAAAAAAAAAAAERIf/aAAgBAwEBPxB7qClo/8QAGBEAAgMAAAAAAAAAAAAAAAAAAAERUWH/2gAIAQIBAT8QUmiVH//EABsQAQEBAAIDAAAAAAAAAAAAAAERACExQVGR/9oACAEBAAE/EBLlXkMydgMLNxiT5RpvWBLgOi+ZpQ9r53//2Q==","aspectRatio":1.7094017094017093,"src":"/static/0543fada4511ed7a0b256c9bde2add6d/14b42/2023_Fiqus_GraphQL_Blog_blog.jpg","srcSet":"/static/0543fada4511ed7a0b256c9bde2add6d/f836f/2023_Fiqus_GraphQL_Blog_blog.jpg 200w,\n/static/0543fada4511ed7a0b256c9bde2add6d/2244e/2023_Fiqus_GraphQL_Blog_blog.jpg 400w,\n/static/0543fada4511ed7a0b256c9bde2add6d/14b42/2023_Fiqus_GraphQL_Blog_blog.jpg 800w,\n/static/0543fada4511ed7a0b256c9bde2add6d/51d11/2023_Fiqus_GraphQL_Blog_blog.jpg 1188w","sizes":"(max-width: 800px) 100vw, 800px"}}},"imageCredits":"unsplash"},"timeToRead":7}},{"node":{"id":"60a6a4fc-9002-51a1-9fc1-b0117d794ad5","html":"<h1>Conociendo GraphQL</h1>\n<p>GraphQL define dos elementos:</p>\n<ul>\n<li>Un lenguaje de consulta</li>\n</ul>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 676px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/351436b1988b4a2416907b219e168787/243f7/Request_graphQL.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 45.33333333333333%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAJABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAQACBf/EABUBAQEAAAAAAAAAAAAAAAAAAAAB/9oADAMBAAIQAxAAAAHuaEYk/8QAFhABAQEAAAAAAAAAAAAAAAAAEAEx/9oACAEBAAEFAmYf/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAFBABAAAAAAAAAAAAAAAAAAAAIP/aAAgBAQAGPwJf/8QAGBAAAgMAAAAAAAAAAAAAAAAAAAEgIXH/2gAIAQEAAT8hxlxP/9oADAMBAAIAAwAAABDI/wD/xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/ED//xAAVEQEBAAAAAAAAAAAAAAAAAAAAEf/aAAgBAgEBPxCI/8QAGxABAAICAwAAAAAAAAAAAAAAAQAxEBFBYXH/2gAIAQEAAT8QLRN3A5M13KPXBP/Z'); background-size: cover; display: block;\"></span>\n  <picture>\n          <source srcset=\"/static/351436b1988b4a2416907b219e168787/e922d/Request_graphQL.webp 375w,\n/static/351436b1988b4a2416907b219e168787/c7990/Request_graphQL.webp 676w\" sizes=\"(max-width: 676px) 100vw, 676px\" type=\"image/webp\">\n          <source srcset=\"/static/351436b1988b4a2416907b219e168787/8a6f5/Request_graphQL.jpg 375w,\n/static/351436b1988b4a2416907b219e168787/243f7/Request_graphQL.jpg 676w\" sizes=\"(max-width: 676px) 100vw, 676px\" type=\"image/jpeg\">\n          <img class=\"gatsby-resp-image-image\" src=\"/static/351436b1988b4a2416907b219e168787/243f7/Request_graphQL.jpg\" alt=\"Request graphQL\" title=\"Request graphQL\" loading=\"lazy\" decoding=\"async\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\">\n        </picture>\n  </a>\n    </span>\n* Un entorno de ejecución para responder a estas consultas a través de la especificación de un esquema tipado en el que se enlistan los datos que el servicio web puede entregar y las operaciones para dar respuesta a las solicitudes de los clientes. \n<p>GraphQL permite que los desarrolladores creen consultas para extraer datos de varias fuentes en una sola llamada a la API.</p>\n<h1>GraphQL vs REST</h1>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 661px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/ca6bb0daf8123e64fa9d293c661b7eb9/b6814/GraphQL_Rest.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 60%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAMABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAECBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAew1Cg//xAAXEAEAAwAAAAAAAAAAAAAAAAABACAx/9oACAEBAAEFAljlP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABQQAQAAAAAAAAAAAAAAAAAAACD/2gAIAQEABj8CX//EABkQAAIDAQAAAAAAAAAAAAAAAAABEBExYf/aAAgBAQABPyFF6NpRRXRH/9oADAMBAAIAAwAAABDbz//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EABoQAQADAQEBAAAAAAAAAAAAAAEAESExUWH/2gAIAQEAAT8QASpTpM9qPEhwxPjGzdsbBrkFHs//2Q=='); background-size: cover; display: block;\"></span>\n  <picture>\n          <source srcset=\"/static/ca6bb0daf8123e64fa9d293c661b7eb9/e922d/GraphQL_Rest.webp 375w,\n/static/ca6bb0daf8123e64fa9d293c661b7eb9/07833/GraphQL_Rest.webp 661w\" sizes=\"(max-width: 661px) 100vw, 661px\" type=\"image/webp\">\n          <source srcset=\"/static/ca6bb0daf8123e64fa9d293c661b7eb9/8a6f5/GraphQL_Rest.jpg 375w,\n/static/ca6bb0daf8123e64fa9d293c661b7eb9/b6814/GraphQL_Rest.jpg 661w\" sizes=\"(max-width: 661px) 100vw, 661px\" type=\"image/jpeg\">\n          <img class=\"gatsby-resp-image-image\" src=\"/static/ca6bb0daf8123e64fa9d293c661b7eb9/b6814/GraphQL_Rest.jpg\" alt=\"GraphQL Rest\" title=\"GraphQL Rest\" loading=\"lazy\" decoding=\"async\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\">\n        </picture>\n  </a>\n    </span>\nLa principal diferencia entre las dos arquitecturas es que GraphQL es independiente de la base de datos y funciona mediante la creación de un único endpoint responsable de aceptar las consultas, en lugar de basarse en el enfoque de la API REST de tener endpoints separados para cada servicio. \n<p>GraphQL es un lenguaje orientado al cliente. Tiene una arquitectura en la que la aplicación front-end decide qué datos obtener y cuánto debe devolver el servidor. Mientras tanto, al usar REST, todo está diseñado en el servidor, por lo que el servidor impulsa la arquitectura.</p>\n<p>No hay problemas de over-fetching y under-fetching. Una ventaja de GraphQl sobre REST es que las respuestas REST contienen demasiados datos o a veces no los suficientes, lo que crea la necesidad de otra solicitud. GraphQL resuelve este problema obteniendo sólo los datos exactos y específicos en una única solicitud.</p>\n<p>Pero esto no es una rivalidad, pueden ser complementarios! la manera en la que el entorno de ejecución que resuelve las queries puede acceder a cualquier tipo de fuente de datos, como lo puede ser un ORM de una base de datos o llamadas a API de 3ros.</p>\n<h1>¿Por qué y cuándo usar GraphQL?</h1>\n<p>Una buena situación para usar GraphQL es cuando:</p>\n<ul>\n<li>Su aplicación necesita manejar un gran número de consultas y mutaciones diferentes, y una API REST tradicional sería difícil de administrar.</li>\n<li>Su aplicación necesita manejar una variedad de tipos de datos diferentes, y un esquema GraphQL permite una mejor organización y documentación de los datos.</li>\n<li>Su aplicación del lado del cliente necesita tener un control preciso sobre los datos que recibe del servidor, y GraphQL permite mayor flexibilidad en la recuperación y consulta de datos.</li>\n<li>Su aplicación va a ser utilizada por otros desarrolladores o sistemas de terceros y desea proporcionarles una API clara y bien documentada.</li>\n<li>Su aplicación necesita manejar actualizaciones en tiempo real y suscripciones, GraphQL proporciona soporte nativo para las suscripciones que puede ayudarte a implementar esta característica.</li>\n</ul>\n<p>Razones para usar GraphQL:</p>\n<ul>\n<li>Flexibilidad: permite al cliente solicitar solo los datos específicos que necesita, evitando la sobrecarga o subestimación de datos.</li>\n<li>Tipado fuerte: GraphQL proporciona un esquema claro y fácil de entender, lo que permite una mejor documentación y un manejo de errores más robusto.</li>\n<li>Eficiente: ya que el cliente puede especificar exactamente qué datos necesita, a menudo se pueden combinar varias solicitudes en una sola solicitud.</li>\n</ul>\n<p>Razones para no usar GraphQL:</p>\n<ul>\n<li>Curva de aprendizaje: GraphQL tiene una curva de aprendizaje más pronunciada que REST, y los desarrolladores pueden necesitar pasar más tiempo para familiarizarse con él.</li>\n<li>Caching: GraphQL no tiene mecanismos de almacenamiento en caché incorporados, lo que puede hacer más difícil almacenar en caché las respuestas del servidor.</li>\n<li>Sobrecarga: si el cliente especifica demasiados datos en su solicitud, puede acabar sobrecargando, lo que puede generar problemas de rendimiento.</li>\n</ul>\n<h1>Pros y contras</h1>\n<p>Pros</p>\n<ul>\n<li>GraphQL es mucho más rápido que otras API de comunicación porque le facilita reducir las requests eligiendo sólo los campos específicos que desea consultar.</li>\n<li>Sistemas complejos y microservicios. Podemos integrar múltiples sistemas detrás de la API de GraphQL. Los unifica y oculta su complejidad. El servidor GraphQL también se utiliza para obtener datos de los sistemas existentes y empaquetarlos en el formato de respuesta GraphQL. Esto es muy beneficioso para las infraestructuras heredadas o las API de terceros que tienen un tamaño enorme y son difíciles de mantener y manejar. Cuando tenemos que migrar de una aplicación backend monolítica a una arquitectura de microservicios, la API GraphQL puede ayudarnos a gestionar la comunicación entre múltiples microservicios fusionándose en un esquema GraphQL.</li>\n<li>Define una forma de datos: Cuando hacemos request GraphQL al servidor, éste devuelve la respuesta en una forma simple, segura y predecible. Así, te facilita escribir una consulta específica de acuerdo a tu requerimiento.</li>\n<li>Código compartido: Podemos compartir los campos GraphQL utilizados en múltiples consultas a un nivel de componente superior para su reutilización. Esta característica se conoce como fragmentos y permite obtener datos diferentes manteniendo el mismo campo de esquema.</li>\n<li>GraphQL es un lenguaje fuertemente tipado donde cada nivel de una consulta GraphQL corresponde a un tipo particular, y cada tipo describe un conjunto de campos disponibles. Por lo tanto, es similar a SQL y proporciona mensajes de error descriptivos antes de ejecutar una consulta.</li>\n<li>Introspection: Podemos consultar un servidor GraphQL por sus tipos de soporte. Crea una potente plataforma para herramientas y software cliente como el framework, Relay, o IDEs como GraphiQL. GraphiQL facilita a los desarrolladores aprender y explorar una API rápidamente.</li>\n<li>No se requiere la última versión. En GraphQL, el conjunto de resultados o datos devueltos es muy específico según la consulta del cliente, por lo que; es muy simple y fácil para el servidor generalizarlo. Cuando añadimos nuevas características de producto, campos adicionales al servidor, no afectan a los clientes existentes. Usted puede utilizar el servidor anterior sin ninguna preocupación porque los campos del servidor pueden ser obsoletos pero siguen funcionando. Este proceso compatible no requiere la necesidad de un número de versión creciente. Puedes ver que Facebook está utilizando la misma versión de GraphQL API en sus aplicaciones.</li>\n</ul>\n<p>Contras</p>\n<ul>\n<li>Las consultas siempre devuelven un código de estado HTTP de 200, independientemente de si la consulta se ha realizado correctamente o no. Si la consulta no tiene éxito, su respuesta JSON tendrá una clave de “errors:” de nivel superior con mensajes de error asociados y stacktrace. Esto puede hacer que sea mucho más difícil hacer la gestión de errores.</li>\n<li>Según su implementación, GraphQL podría requerir estrategias de gestión de API diferentes a las API de REST, sobre todo si se tienen en cuenta los precios y los límites de frecuencia.</li>\n<li>La flexibilidad y riqueza del lenguaje de consulta también añade complejidad que puede no valer la pena para APIs mas sencillas.</li>\n</ul>\n<h1>Ejemplo básico:</h1>\n<p>Para este ejemplo vamos a estar utilizando la librería de <a href=\"https://www.apollographql.com/docs/\">apollo</a>  que nos brinda en este caso un cliente para react y un servidor para nodeJS\r\nEl schema definido será uno muy simple de un blog donde los usuarios pueden tener posts asociados</p>\n<deckgo-highlight-code language=\"typescript\" terminal=\"ubuntu\"  >\n          <code slot=\"code\">type User {\r\n  id: ID!\r\n  name: String!\r\n  lastName: String!\r\n  emails: [String!]\r\n  age: Int!\r\n  posts: [Post]\r\n}\r\n\r\ntype Post {\r\n  id: ID!\r\n  title: String!\r\n  content: String!\r\n}\r\n\r\ntype Query {\r\n  user(id: ID!): User\r\n  post(id: ID!): Post\r\n  allUsers: [User]\r\n  allPosts: [Post]\r\n}</code>\n        </deckgo-highlight-code>\n<p>Server:</p>\n<deckgo-highlight-code language=\"javascript\" terminal=\"ubuntu\"  >\n          <code slot=\"code\">const { ApolloServer, gql } = require(&#39;apollo-server&#39;);\r\n\r\n\r\n// Definir tipos de datos y resolvers\r\nconst typeDefs = gql`\r\n type User {\r\n   id: ID!\r\n   name: String!\r\n   lastName: String!\r\n   emails: [String!]\r\n   age: Int!\r\n   posts: [Post]\r\n }\r\n type Post {\r\n   id: ID!\r\n   title: String!\r\n   content: String!\r\n }\r\n type Query {\r\n   user(id: ID!): User\r\n   post(id: ID!): Post\r\n   allUsers: [User]\r\n   allPosts: [Post]\r\n }\r\n`;\r\n\r\n\r\nconst users = [\r\n { name: &#39;John&#39;, lastName: &#39;Doe&#39;, emails: [&#39;johndoe@example.com&#39;], age: 30 },\r\n { name: &#39;Jane&#39;, lastName: &#39;Doe&#39;, emails: [&#39;janedoe@example.com&#39;], age: 25 },\r\n];\r\n\r\n\r\nconst posts = [\r\n { id: &#39;1&#39;, title: &#39;My first post&#39;, content: &#39;This is my first post&#39; },\r\n { id: &#39;2&#39;, title: &#39;My second post&#39;, content: &#39;This is my second post&#39; },\r\n];\r\n\r\n\r\nconst resolvers = {\r\n Query: {\r\n   // En los resolvers podriamos hacer una llamada a una api de 3ros\r\n   user: (_, { id }) =&gt; users.find((user) =&gt; user.id === id),\r\n   post: (_, { id }) =&gt; posts.find((post) =&gt; post.id === id),\r\n   allUsers: () =&gt; users,\r\n   allPosts: () =&gt; posts,\r\n },\r\n};\r\n\r\n\r\n// Creamos la instancia del servidor\r\nconst server = new ApolloServer({ typeDefs, resolvers });\r\n\r\n// Inicializamos el servidor\r\nserver.listen().then(({ url }) =&gt; {\r\n console.log(`Server ready at ${url}`);\r\n});\r\n</code>\n        </deckgo-highlight-code>\n<p>Cliente de react</p>\n<deckgo-highlight-code language=\"javascript\" terminal=\"ubuntu\"  >\n          <code slot=\"code\">import React from &#39;react&#39;;\r\nimport { ApolloClient, ApolloProvider, gql, useQuery } from &#39;@apollo/client&#39;;\r\n\r\n\r\nconst client = new ApolloClient({\r\n uri: &#39;http://localhost:4000/graphql&#39;,\r\n});\r\n\r\n\r\nfunction User({ id }) {\r\n const { loading, error, data } = useQuery(gql`\r\n   query User($id: ID!) {\r\n     user(id: $id) {\r\n       name\r\n       lastName\r\n       emails\r\n       age\r\n     }\r\n   }\r\n `, { variables: { id } });\r\n\r\n\r\n if (loading) return &lt;p&gt;Loading...&lt;/p&gt;;\r\n if (error) return &lt;p&gt;Error :(&lt;/p&gt;;\r\n\r\n\r\n return (\r\n   &lt;div&gt;\r\n     &lt;h2&gt;{data.user.name} {data.user.lastName}&lt;/h2&gt;\r\n     &lt;p&gt;Age: {data.user.age}&lt;/p&gt;\r\n     &lt;p&gt;Emails: {data.user.emails.join(&#39;, &#39;)}&lt;/p&gt;\r\n   &lt;/div&gt;\r\n );\r\n}\r\n\r\n\r\nfunction App() {\r\n return (\r\n   &lt;ApolloProvider client={client}&gt;\r\n     &lt;User id=&quot;1&quot; /&gt;\r\n   &lt;/ApolloProvider&gt;\r\n );\r\n}\r\n\r\n\r\nexport default App;</code>\n        </deckgo-highlight-code>\n<p>En este ejemplo, el componente User utiliza el hook useQuery de react-apollo para consultar al servidor un usuario específico por ID. El componente ApolloProvider se utiliza para proporcionar la instancia de cliente a toda la aplicación React. Cuando el componente es renderizado</p>\n<h1>Algunos extras:</h1>\n<p>GraphQL fue desarrollado internamente por Facebook en 2012 antes de ser liberado públicamente en 2015. ​ El 7 de noviembre de 2018, el proyecto GraphQL fue transferido de Facebook a la recién establecida Fundación GraphQL, alojada por la Fundación Linux.</p>\n<p>Los servidores de GraphQL están disponibles para múltiples lenguajes, incluyendo Haskell, Javascript, Perl, Python, Ruby, Java, C++,11​ C#, Scala, Go, Rust, Elixir, Erlang, PHP, R, y Clojure.</p>\n<p>Documentación oficial de GraphQL: <a href=\"https://graphql.org/learn/\">https://graphql.org/learn/</a>\r\nDocumentación oficial de Apollo: <a href=\"https://www.apollographql.com/docs/\">https://www.apollographql.com/docs/</a></p>","frontmatter":{"lang":"es","type":"post","title":"Conociendo Graphql","author":"Jeronimo Clinaz","slug":"/graphql","date":"2023-02-08","tags":["GraphQL","Apollo","Rest"],"image":{"childImageSharp":{"fluid":{"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAMABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAABQACA//EABUBAQEAAAAAAAAAAAAAAAAAAAMC/9oADAMBAAIQAxAAAAFznss0VhqH/8QAGhAAAgMBAQAAAAAAAAAAAAAAAQIAAxIRE//aAAgBAQABBQKWMQuhLDlPR4T0/wD/xAAaEQACAgMAAAAAAAAAAAAAAAAAAQIDFCFR/9oACAEDAQE/AY1Oa0Y66f/EABgRAAIDAAAAAAAAAAAAAAAAAAACERMh/9oACAECAQE/AXaMLT//xAAZEAEBAAMBAAAAAAAAAAAAAAABABEhIjL/2gAIAQEABj8CubaSl6bLf//EABkQAQEBAQEBAAAAAAAAAAAAAAERADEQUf/aAAgBAQABPyHjHHU1unxPy5OuDwEsV3//2gAMAwEAAgADAAAAEAMP/8QAFxEAAwEAAAAAAAAAAAAAAAAAAAERIf/aAAgBAwEBPxB7qClo/8QAGBEAAgMAAAAAAAAAAAAAAAAAAAERUWH/2gAIAQIBAT8QUmiVH//EABsQAQEBAAIDAAAAAAAAAAAAAAERACExQVGR/9oACAEBAAE/EBLlXkMydgMLNxiT5RpvWBLgOi+ZpQ9r53//2Q==","aspectRatio":1.7094017094017093,"src":"/static/0543fada4511ed7a0b256c9bde2add6d/14b42/2023_Fiqus_GraphQL_Blog_blog.jpg","srcSet":"/static/0543fada4511ed7a0b256c9bde2add6d/f836f/2023_Fiqus_GraphQL_Blog_blog.jpg 200w,\n/static/0543fada4511ed7a0b256c9bde2add6d/2244e/2023_Fiqus_GraphQL_Blog_blog.jpg 400w,\n/static/0543fada4511ed7a0b256c9bde2add6d/14b42/2023_Fiqus_GraphQL_Blog_blog.jpg 800w,\n/static/0543fada4511ed7a0b256c9bde2add6d/51d11/2023_Fiqus_GraphQL_Blog_blog.jpg 1188w","sizes":"(max-width: 800px) 100vw, 800px"}}},"imageCredits":"unsplash"},"timeToRead":7}}]}},"pageContext":{"slug":"/graphql","language":"es","intl":{"language":"es","languages":["es","en"],"messages":{"Home":"Home","Servicios":"Servicios","Cultura":"Cultura","Labs":"Labs","Blog":"Blog","Articles":"Articles","footer.designby":"Un trabajo intercooperativo de","footer.coopName":"el maizal y nayra","footer.coopName1":"el maizal","footer.coopName2":"nayra","footer.coopName1Path":"https://elmaizal.coop.ar","footer.coopName2Path":"https://nayra.coop","footer.preposition":"y","footer.disclaimer":"Salvo que se indique lo contrario, el contenido de este sitio tiene una licencia de ","footer.licenseName":"Creative Commons Attribution","footer.licenseIconAlt":"Creative Commons Attribution logo","header.logoAlt":"logo Lawal","header.iconTogglerAlt":"icono para abrir menú","header.iconTogglerCloseAlt":"icono para cerrar menú","homepage.title":"Homepage","homepage.imageAlt":" ","homepage.imageAltMobile":" ","homepage.leadLine1":" Somos una empresa","homepage.leadUnderlined":" cooperativa","homepage.leadLine2":" de base tecnológica,","homepage.leadBold":" especializada en Inteligencia Artificial","homepage.leadLine3":" y sistemas de alta concurrencia.","homepageCulture.title":"Cultura","homepageCulture.birdImage":"bird.svg","homepageCulture.birdImageAlt":"ilustración de un pájaro","homepageCulture.image":"homepageCulture.svg","homepageCulture.imageAlt":"ilustración que representa la sección cultura","homepageCulture.descriptionLine1":"Lawal es una empresa tecnológica administrada, gestionada y gobernada por las personas que trabajan en ella, en otras palabras, ","homepageCulture.underlinedText":" somos una cooperativa de trabajo. ","homepageCulture.descriptionLine2":" Siempre que trates con una persona de Lawal vas a tratar con una persona con capacidad de acción, decisión y compromiso total con los proyectos.","homepageCulture.btnText":"ver más","homepageLabs.title":"Lawal Experimental","homepageLabs.subtitle":"Experimentamos con la tecnología y el cooperativismo!","homepageLabs.image":"homepageLabs.svg","homepageLabs.imageAlt":"ilustración que representa la sección cultura","homepageLabs.imageAltMobile":"ilustración que representa la sección cultura","homepageLabs.descriptionLine1":"En Lawal elegimos usar la tecnología como herramienta para explorar","homepageLabs.descriptionBold1":" nuestro territorio y nuestras mentes","homepageLabs.descriptionLine2":" investigando y aplicando así nuevas tecnologías como","homepageLabs.descriptionBold2":" Elixir, Rust, AI y Blockchain ","homepageLabs.descriptionComma":" ,","homepageLabs.descriptionBold3":" y principios y técnicas de organización horizontal y participación amplia","homepageLabs.descriptionLine4":" para crear programas, aplicaciones, experiencias y espacios","homepageLabs.descriptionBold4":" que nos permitan tener vidas con otros propositos mas allá del sostén económico","homepageLabs.descriptionDot":".","homepageLabs.btnText":"ver más","button.verMas":"ver más","button.send":"enviar","button.read":"leer","verMasArticulos":"ver todos los artículos","y":" y ","contactForm.title":"Contactanos","contactForm.nameField":"Nombre","contactForm.emailField":"E-mail","contactForm.requiredFieldError":"Por favor, complete el campo requerido.","contactForm.textAreaField":"Mensaje","contactForm.messageSent":"Tu mensaje ha sido enviado.","contactForm.thankYou":"Gracias por comunicarte con Lawal","contactForm.email":"info@lawal.com.ar","contactForm.sedes":"Sede","contactForm.office1":"Villa La Angostura, Neuquén, Argentina","services.title":"Servicios","services.tagsTitle":"Tecnologías","services.btnText":"ir a servicios","service_datos.service":"Ciencia de Datos","service_datos.description":"Este área se dedica a la limpieza, extracción y análisis de datos con el fin de poder servir de alimento para procesos de Inteligencia Artificial o Aprendizaje Automático. Es de esencial importancia procesar los datos para lograr que sean de fácil entendimiento, así como su uso para llegar a los objetivos planteados.","service_datos.tags.0":"Python","service_datos.tags.1":"Pandas","service_datos.tags.2":"Numpy","service_datos.tags.3":"Seaborn","service_datos.image":"datos","service_datos.link":" ","service_inteligenciaArtificial.service":"Inteligencia Artificial","service_inteligenciaArtificial.description":"El Aprendizaje Automático es un subcampo de la Inteligencia Artificial en el que se tiene como objetivo que las \"computadoras aprendan\". A partir de datos recolectados y procesados, diseñamos, construimos y entrenamos modelos que nos permitan predecir eventos futuros, clasificar imágenes, reconocer entidades en textos y muchas otras cosas más.","service_inteligenciaArtificial.tags.0":"Python","service_inteligenciaArtificial.tags.1":"Pandas","service_inteligenciaArtificial.tags.2":"Numpy","service_inteligenciaArtificial.tags.3":"Seaborn","service_inteligenciaArtificial.image":"inteligenciaArtificial","service_inteligenciaArtificial.link":" ","service_altaConcurrencia.service":"Alta Concurrencia","service_altaConcurrencia.description":"Utilizamos lenguajes de programación funcional en tiempo real y muy adoptados en el mercado, que soportan niveles de altísima concurrencia y distribución, teniendo como resultado sistemas que responden a gran velocidad ante altas demandas.","service_altaConcurrencia.tags.0":"Earlang","service_altaConcurrencia.tags.1":"Elixir","service_altaConcurrencia.tags.2":"Phoenix Framework","service_altaConcurrencia.tags.3":"LiveView","service_altaConcurrencia.image":"altaConcurrencia","service_altaConcurrencia.link":" ","service_blockchain.service":"Blockchain | Fintech","service_blockchain.description":"Estamos desarrollando fintech, que son las nuevas aplicaciones, procesos, productos o modelos de negocios en la industria de los servicios financieros compuestos de uno o más servicios financieros complementarios y puestos a disposición del público vía Internet.","service_blockchain.tags.0":"Python","service_blockchain.tags.1":"Ethereum","service_blockchain.image":"blockchain","service_blockchain.link":" ","service_fullstack.service":"Fullstack","service_fullstack.description":"Desarrollamos aplicaciones web/mobile/desktop con diferentes tecnologías que permitan resolver problemáticas de organizaciones, cooperativas y empresas y poder realizar sus procesos de manera más eficiente.","service_fullstack.tags.0":"Django","service_fullstack.tags.1":"Phoenix","service_fullstack.tags.2":"Phoenix LiveView","service_fullstack.tags.3":"ReactJS","service_fullstack.tags.4":"VueJS","service_fullstack.tags.5":"React Native","service_fullstack.image":"fullstack","service_fullstack.link":" ","service_subsection.title":"Asesoramiento a Cooperativas","service_subsection.description":"Realizamos capacitaciones técnicas y/o de cooperativismo para organizaciones y cooperativas donde buscamos transmitir de forma amena y sistematizada los conocimientos adquiridos en el ámbito tecnológico y cooperativo.","service_subsection.image":"capacitacion","service_subsection.featuredServiceImageAlt":"Capacitación, ilustración animada","service_subsection.link":"servicios/#capacitacion","culture.title":"Cultura","culture.subtitle":"¡Somos una cooperativa de trabajo!","culture.description":"Lawal es una empresa tecnológica administrada, gestionada y gobernada por las personas que trabajan en ella. Siempre que trates con una persona de Lawal vas a tratar con una persona con capacidad de acción, decisión y compromiso total con los proyectos.","culture_historia.title":"La Raíz Colectiva","culture_historia.imageMobile":"equipoMobile","culture_historia.imageAltMobile":"equipo Lawal","culture_historia.imageDesktop":"equipoDesktop","culture_historia.imageAlt":"equipo Lawal","culture_historia.content_line1":"Lawal toma forma en el transcurso del año 2024, a través de la decisión de construir un espacio de trabajo arraigado en el territorio patagónico que habitamos. Quienes traccionamos que esto suceda, venimos de transitar años de distintas experiencias cooperativas y particularmente en el ámbito del desarrollo de software, y ese conocimiento puesto en común nos dio la certeza del potencial de las estructuras colaborativas y autogestionadas.","culture_historia.content_line2":"Lawal (o lahual) es el nombre dado por el pueblo mapuche-huilliche al árbol alerce (Fitzroya cupressoides). Su significado en lengua mapudungun es “vida después de la vida.” Eso mismo representa esta cooperativa para quienes la construimos día a día.","culture_historia.content_line3":"Somos una empresa organizada como Cooperativa de Trabajo, porque entendemos al asociativismo como herramienta de vida y nos agrupa el saber  y el hacer tecnológico.","culture_historia.content_line4":"La propiedad es colectiva, y así construimos acuerdos que dan forma a nuestra cotidianeidad, estructura viva que nos permite innovar, experimentar y elegir qué y cómo producimos, de manera democrática.","culture_historia.subtitle":"¡Trabajamos con lógicas de producción diferentes a las convencionales!","culture_historia.content_line5":"La voz de todas las personas que integramos la cooperativa tiene lugar y peso en las decisiones que marcan nuestro hacer. ","culture_federales.title1":"Creatividad & Tecnología","culture_federales.imageCreatividad":"creatividad","culture_federales.imageCreatividadAlt":" ","culture_federales.content1":"Nos motiva explorar tecnologías de vanguardia y desarrollar soluciones con lenguajes y arquitecturas robustas, eficientes y escalables. ","culture_federales.content2":"Construimos y participamos en diversos proyectos utilizando Elixir y Rust, lenguajes en los que nos especializamos para diseñar sistemas concurrentes, resilientes y de alto rendimiento. Nuestra exploración nos ha llevado a profundizar en tecnologías como Blockchain y, cada vez más, en Inteligencia Artificial, particularmente a través de la implementación y uso de Large Language Models (LLMs).","culture_federales.title2":"Exploración Amplia","culture_federales.content3":"Nuestra identidad colectiva está compuesta por la diversidad de experiencias que traemos. A la tecnología la cruzamos con la música, las ingenierías, la gestión cultural, la soberanía alimentaria, deportes en la naturaleza, el yoga, las radios comunitarias, las artes marciales, el mutualismo. Nos hacen los distintos senderos que transitamos, la oscilación entre nuestras vidas personales y los proyectos en conjunto. Nos reconocemos amigxs. La sinergía de trabajo nos habilita divertirnos, planificar objetivos, y abordar los desafíos en equipo. Creemos que la creatividad y la técnica se retroalimentan cuando se trabaja de este modo, con estructuras horizontales donde se ponen en común y se comparten las ideas, las responsabilidades, el entusiasmo. Valoramos trabajar con libertad y autonomía, profundizando el compromiso con cada proyecto que abordamos.","culture_facttic.title":"Puentes hacia el Territorio","culture_facttic.subtitle":"Compartimos conocimiento a través del Hackerspace","culture_facttic.content_line1_part1":"Invertimos en nuestra formación, y a su vez, dedicamos energía en generar espacios donde el conocimiento fluya de manera circular con personas y grupos externos a la cooperativa, para romper con la privatización del conocimiento, y aportar a formas de vida que integren la tecnología sin perder el horizonte de la autonomía y la relación comunitaria. De eso se trata el espacio de","culture_facttic.content_line1_facttic":" Hackerspace","culture_facttic.content_line1_part2":", laboratorio abierto para el aprendizaje.","culture_facttic.content_line2":"Creemos que el futuro también es un territorio en disputa, y desde nuestro hacer, es posible transmitir otros paradigmas de trabajo y cultura.","culture_facttic.content_line3":"El cooperativismo como una forma de reexistencia, una provocación para asumir un lugar de responsabilidad y acción en las comunidades en las que vivimos.","culture_internacional.title":"Los Ecosistemas que Integramos","culture_internacional.content_line1":"Elegimos ser cooperativas, y eso lleva al fortalecimiento de lazos no sólo territoriales sino también estructurales hacia la construcción de otras economías posibles. Somos parte del movimiento de la Economía Social y Solidaria (ESS), y de manera sectorial, nuestro trabajo dedicado a la industria tecnológica nos une a FACTTIC, la Federación Argentina de Cooperativas de Trabajo, Tecnología, Innovación y Conocimiento. Somos más de 40 cooperativas agrupadas, espacio de construcción desde el que generamos oportunidades laborales, proyectos sociales y ayuda mutua desde hace más de 10 años.","culture_internacional.content_line2":"Nos entendemos como actores sociales territoriales, y por eso es que quienes integramos Lawal, formamos parte de otros proyectos sociales de Villa La Angostura. Así es que acompañamos el desarrollo de la Mutual La Correntosa, con base en la organización de vecinxs preocupadxs por la soberanía alimentaria, y dedicadxs al fortalecimiento de los lazos entre consumidores y productores de la agricultural familiar y/o cooperativos.","culture_internacional.content_line3":"A su vez, interesadxs en la historia de la Patagonia, desde su ancestralidad a las construcciones de sentido de las que somos hoy parte, así como del sostenimiento de espacios culturales comunitarios, es que nos vinculamos a la Biblioteca Popular Osvaldo Bayer, e integramos proyectos en conjunto como lo son Archivos del Sur.","labs.title":"Experimental","labs.subtitle":"En Lawal elegimos usar la tecnología como herramienta para explorar nuestro territorio y nuestras mentes.","labs.content":" Investigamos y aplicamos nuevas tecnologías como Elixir, Rust, AI y Blockchain. También nos basamos en principios y técnicas de organización horizontal y participación amplia. Así creamos programas, aplicaciones, experiencias y espacios que nos permitan tener vidas con otros propósitos mas allá del sostén económico.","casos_de_exito.title":"Experiencias","casos_de_exito.tagsTitle":"Tecnologías Investigadas","casos_de_exito.imageAltLine1":"imagen del proyecto ","casos_de_exito.btnTextVerMas":"ver más","casos_de_exito.btnTextGithub":"ir a Github","blog.title":"Blog","blogPost.tagsTitle":"Etiquetas relacionadas","blogPost.relatesPost":"Artículos relacionados","blogPost.verTodosBtn":"Ver todos los artículos","page404.title":"Error 404","page404.descriptionLine1":"No pudimos encontrar lo que estabas buscando.","page404.descriptionLine2":"Te invitamos a seguir navegando nuestro sitio tocando el siguiente botón","page404.btnText":"volver al home","page404.btnHref":"/","page404.imageAlt":"ilustración de ina","page404.imageAltMobile":"ilustración de ina"},"routed":true,"originalPath":"/post/graphql","redirect":true,"redirectDefaultLanguageToRoot":false,"defaultLanguage":"es","fallbackLanguage":"es","ignoredPaths":[]}}},
    "staticQueryHashes": ["632761789"]}